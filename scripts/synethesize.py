"""
Script to synthesize .lean files from source code
definitions using the templating system.
"""

import json
import os
from pathlib import Path
import subprocess

ALL_OEIS_RESULTS_FILE = os.environ.get(
    "ALL_OEIS_RESULTS_FILE", os.path.expanduser("~/oeis_results_all.json")
)

SOLUTIONS_FILE_PATH = os.environ.get(
    "SOLUTIONS_FILE_PATH",
    os.path.expanduser("~/gits/lean4/oeis-synthesis/src/results/solutions"),
)

SEQUENCE_LIB_ROOT = Path(__file__).parent.parent.resolve()
print(f"Using {SEQUENCE_LIB_ROOT} for root of sequencelib")

# string to use for the Authors line in the generated .lean files
AUTHORS = "Walter and Joe's Synth Bot"

# Directory to save generated Lean files to.
# Needs to be somewhere that has a checkout of SequenceLib.
OUTPUT_DIR = os.path.expanduser("~/gits/lean4/sequencelib/Sequencelib/synth")


class BuildException(Exception):
    pass


class AutoDerivationException(BuildException):
    pass


def get_all_seq_data():
    with open(ALL_OEIS_RESULTS_FILE, "r") as f:
        return json.load(f)


def generate_lean_file(tag, name, offset, authors, max_index, lean_source):
    """
    Use the `lean_source` generated by the transpiler to create a .lean file that
    can be type checked.
    """
    if not max_index:
        result = subprocess.run(
            [
                "python",
                "new_sequence_template.py",
                "-t",
                tag,
                "-n",
                name,
                "-o",
                offset,
                "-a",
                authors,
                "-s",
                lean_source,
            ],
            capture_output=True,
        )
    else:
        result = subprocess.run(
            [
                "python",
                "new_sequence_template.py",
                "-t",
                tag,
                "-n",
                name,
                "-o",
                offset,
                "-a",
                authors,
                "-s",
                lean_source,
                "-m",
                max_index,
            ],
            capture_output=True,
        )
    file_name = f"{name}.lean"
    out_path = os.path.join(OUTPUT_DIR, file_name)
    with open(out_path, "w") as f:
        f.write(result.stdout.decode())
    return out_path


def compile_lean(path):
    """
    Attemps to compile a single lean source file at `path`.
    Raises an exception if the build fails.

    """
    try:
        result = subprocess.run(
            ["lake", "build", path], capture_output=True, cwd=SEQUENCE_LIB_ROOT
        )
    except Exception as e:
        print(f"Got exception trying to run lake build; e: {e}")
        raise e
    out = result.stdout.decode()
    er = result.stderr.decode()
    if "error" in out:
        # try to parse the error
        if "Auto derivation" in out:
            # likely an issue with the autoderivation
            raise AutoDerivationException(f"Auto derivation failed: {out}")
        else:
            raise BuildException(f"Build failed: {out}")
    elif "Build completed successfully" in out:
        return out
    raise Exception(f"Unexpected output from build: {out}; {er}")


def process_failed_lean_file(path):
    """
    Do something with the .lean files that fail to compile.
    """
    new_path = f"{path}.FAILED"
    os.rename(path, new_path)


def process_sequence(seq_id, offset, code, values, lean_source=None):
    """
    Process a single sequence from the solutions file.
    """
    print(f"Top of process_sequence for: {seq_id}, {offset}, {code}")
    times = 1
    while times <= 2:
        # First, we generate the Lean associated with this code for the DSL
        if not lean_source:
            try:
                result = subprocess.run(
                    ["lake", "exe", "genseq", seq_id, str(offset), str(code)],
                    capture_output=True,
                    cwd=SEQUENCE_LIB_ROOT,
                )
                if result.returncode == 0:
                    lean_source = result.stdout
                    print(f"Got lean source: {lean_source}")
                else:
                    raise Exception(
                        f"Error: non-zero return code from genseq: {result.returncode}; stdout: {result.stdout}; stderr:{result.stderr}"
                    )
            except Exception as e:
                print(f"Got exception running genseq; e: {e}")
                raise e
        tag = seq_id
        # for now, use the tag as the name also; could look at other ways to generate the name
        name = seq_id
        authors = AUTHORS

        # only try to auto derive the first time:
        max_index = None
        if times == 1:
            max_index = len(values)
            # currently aut derive only supports up to 100
            if max_index > 100:
                max_index = 100
            max_index = str(max_index)
        else:
            print("building without max_index")
        # Use the template generator to generate a .lean file
        out_path = generate_lean_file(
            tag, name, offset, authors, max_index, lean_source
        )

        # Try to compile the lean source
        try:
            compile_lean(out_path)
            times += 2  # compilation worked, so we're done
        except AutoDerivationException as e:
            print(f"Auto derivation failed for {tag}; error: {e}")
            times += 1  # try one more time
        except BuildException as e:
            process_failed_lean_file(out_path)
            print(f"Build failed for sequence {tag}; error: {e}")
            times += 2  # give up
        except Exception as e:
            process_failed_lean_file(out_path)
            print(f"Build failed for sequence {tag}; error: {e}")
            times += 2  # give up


def process_solutions_file(start=101, stop=500):
    """
    Process the solutions file, synthesizing a .lean file for each sequence in the solutions.
    """
    results = {}
    seq_data = get_all_seq_data()
    tot_seqs_processed = 0
    with open(SOLUTIONS_FILE_PATH, "r") as f:
        idx = 0
        current_seq_id = None
        for line in f:
            idx += 1
            # odd numbered lines should be the start of a new sequence
            if idx % 2 == 1:
                if not line.startswith("A") or not ":" in line:
                    print(f"Unexpected beginning of sequence line {idx}")
                    print(f"Line:{line}")
                    continue
                parts = line.split(":")
                # the sequence id's in the solutions file are missing 0s
                current_seq_id = parts[0]
                if len(current_seq_id) < 7:
                    current_seq_id = (
                        current_seq_id[0]
                        + "0" * (7 - len(current_seq_id))
                        + current_seq_id[1:]
                    )
                values = parts[1].strip()
                results[current_seq_id] = {"values": values, "code": ""}
            # even numbered lines should be the code
            else:
                tot_seqs_processed += 1
                if tot_seqs_processed < start:
                    continue
                if tot_seqs_processed > stop:
                    break
                # if for some reason we weren't able to get the sequence id, skip
                # the code as well
                if not current_seq_id:
                    continue
                # code is the entire line
                code = line.strip()
                results[current_seq_id]["code"] = code
                values = results[current_seq_id]["values"]
                offset = seq_data[current_seq_id]["offset"]
                if "," in offset:
                    offset = offset.split(",")[0]
                process_sequence(current_seq_id, offset, code, values)
                current_seq_id = None  # set to None, as this sequence as been processed
    return results


def test():
    lean_source = """noncomputable def PowersOfPrimes : ℕ → ℕ
   | 0 => 1  -- dummy value, since sequence starts at offset 1
   | 1 => 1
   | n + 1 => nth IsPrimePow (n - 1)"""
    tag = "A000961"
    name = "PrimePowers"
    offset = "1"
    max_index = "10"
    authors = "Walter and Joe's synth bot"
    generate_lean_file(tag, name, offset, authors, max_index, lean_source)


def test2():
    lean_source = """def Divisors (n : ℕ) := n.divisors.card"""
    tag = "A000005"
    name = "Divisors"
    offset = "1"
    max_index = "10"
    authors = "Walter and Joe's synth bot"
    generate_lean_file(tag, name, offset, authors, max_index, lean_source)


def test3():
    lean_source = """def Divisors (n : ℕ) := n.divisors.card"""
    tag = "A000005"
    name = "Divisors"
    code = "foo"  # doesn't matter, will be ignored since passing lean_source
    offset = "1"
    values = [1]
    process_sequence(tag, offset, code, values, lean_source=lean_source)


def test4():
    lean_source = """noncomputable def Divisors (n : ℕ) := n.divisors.card Foobar"""
    tag = "A000005b"
    name = "Divisors"
    code = "foo"  # doesn't matter, will be ignored since passing lean_source
    offset = "1"
    values = [1]
    process_sequence(tag, offset, code, values, lean_source=lean_source)


def main():
    # test()
    # test2()
    # test3()
    # test4()
    process_solutions_file()


if __name__ == "__main__":
    main()
